---
// Componente para el slime que aparece en las terminales
const { lang = "es", labels = {} } = Astro.props;
---

<div id="terminal-slime" class="terminal-slime">
  <img src="/Slime_Player.png" alt={labels.slime?.alt || "Slime mascot"} class="slime-image" />
</div>

<!-- Diálogo separado fuera del contenedor del slime -->
<div class="slime-dialog" id="slime-dialog">
  <div class="dialog-content">
    <strong>{labels.slime?.greeting || "HELLO!"}</strong><br>
    <span set:html={labels.slime?.message || "Looks like you like slimes<br>soon you'll have more wait for it..."}></span>
  </div>
</div>

<script is:raw>
  function initTerminalSlime() {
    const slime = document.getElementById('terminal-slime');
    const dialog = document.getElementById('slime-dialog');
    if (!slime || !dialog) return;

    // Asegurar que el diálogo esté oculto inicialmente
    dialog.style.display = 'none';
    
    console.log('Dialog encontrado:', dialog);
    console.log('Dialog text:', dialog.textContent);

    // Obtener solo la sección "about"
    const aboutSection = document.querySelector('#about');
    
    // Función para mostrar/ocultar slime solo en la sección about
    function updateSlimeVisibility() {
      if (!aboutSection) {
        // Si no hay sección about, ocultar el slime
        slime.style.display = 'none';
        return;
      }

      const scrollY = window.scrollY;
      const windowHeight = window.innerHeight;
      const sectionRect = aboutSection.getBoundingClientRect();
      const sectionTop = scrollY + sectionRect.top;
      const sectionBottom = sectionTop + sectionRect.height;

      // Verificar si la sección about está en el viewport
      const isAboutVisible = sectionTop < scrollY + windowHeight && sectionBottom > scrollY;

      // Mostrar slime solo si la sección about está visible
      if (isAboutVisible) {
        // Buscar terminales con diferentes selectores en la sección about
        const terminal = aboutSection.querySelector('.bg-black\\/90') || 
                       aboutSection.querySelector('.bg-black\\/80') ||
                       aboutSection.querySelector('[class*="bg-black"]');
        
        if (terminal) {
          const terminalRect = terminal.getBoundingClientRect();
          
          // Verificar que la terminal esté visible
          if (terminalRect.top < windowHeight && terminalRect.bottom > 0) {
            // Posicionar el slime más escondido en la esquina, muy sutil
            const slimeSize = window.innerWidth <= 480 ? 30 : window.innerWidth <= 768 ? 35 : 40;
            const peekAmount = window.innerWidth <= 480 ? 8 : window.innerWidth <= 768 ? 10 : 12;
            
            slime.style.position = 'fixed';
            slime.style.top = `${terminalRect.top - (slimeSize - peekAmount)}px`;
            slime.style.right = `${window.innerWidth - terminalRect.right - (slimeSize - peekAmount)}px`;
            slime.style.zIndex = '10'; // Detrás de la terminal (que tiene z-index más alto)
            slime.style.display = 'block';
            
            // Agregar clase para efecto de asomarse
            slime.classList.add('slime-peeking');
            
            // Agregar animación de entrada
            setTimeout(() => {
              slime.classList.add('slime-visible');
            }, 100);
          }
        }
      } else {
        // Ocultar slime si la sección about no está visible
        slime.classList.remove('slime-visible');
        setTimeout(() => {
          if (!slime.classList.contains('slime-visible')) {
            slime.style.display = 'none';
          }
        }, 300);
      }
    }

    // Inicializar slime como oculto
    slime.style.display = 'none';
    slime.style.opacity = '0';
    slime.style.transform = 'translateY(-20px)';

    // Event listeners
    window.addEventListener('scroll', () => {
      updateSlimeVisibility();
      // Reposicionar el diálogo si está visible
      if (dialog.style.display === 'block') {
        positionDialog();
      }
    });
    window.addEventListener('resize', () => {
      updateSlimeVisibility();
      // Reposicionar el diálogo si está visible
      if (dialog.style.display === 'block') {
        positionDialog();
      }
    });
    
  // Función para posicionar el diálogo sobre el slime
  function positionDialog() {
    const slimeRect = slime.getBoundingClientRect();
    const dialogWidth = 200; // max-width del diálogo
    const dialogHeight = 140; // altura estimada
    
    // Posicionar el diálogo arriba del slime
    dialog.style.position = 'fixed';
    dialog.style.left = `${slimeRect.left + (slimeRect.width / 2) - (dialogWidth / 2)}px`;
    dialog.style.top = `${slimeRect.top - dialogHeight - 20}px`;
    dialog.style.zIndex = '99999';
  }

  // Event listeners para el diálogo - versión simplificada
  slime.addEventListener('mouseenter', () => {
    console.log('Hover iniciado');
    positionDialog();
    dialog.style.display = 'block';
    dialog.style.opacity = '1';
    dialog.style.visibility = 'visible';
  });
  
  slime.addEventListener('mouseleave', () => {
    console.log('Hover terminado');
    dialog.style.display = 'none';
    dialog.style.opacity = '0';
    dialog.style.visibility = 'hidden';
  });

  // Evento de click para probar que funciona
  slime.addEventListener('click', () => {
    console.log('Click en slime');
    positionDialog();
    if (dialog.style.display === 'none') {
      dialog.style.display = 'block';
      dialog.style.opacity = '1';
      dialog.style.visibility = 'visible';
    } else {
      dialog.style.display = 'none';
      dialog.style.opacity = '0';
      dialog.style.visibility = 'hidden';
    }
  });
    
    // Inicializar posición
    updateSlimeVisibility();

    console.log('Terminal Slime inicializado');
  }

  // Inicializar cuando el DOM esté listo
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initTerminalSlime);
  } else {
    initTerminalSlime();
  }
</script>

<style>
  .terminal-slime {
    position: fixed;
    z-index: 10; /* Detrás de las terminales por defecto */
    pointer-events: auto; /* Habilitar hover */
    transition: all 0.3s ease;
    opacity: 0;
    transform: translateY(-20px);
    cursor: pointer;
  }

  .terminal-slime:hover {
    z-index: 1001 !important; /* Enfrente de todo cuando hay hover */
    transform: translateY(-10px) scale(1.8) !important;
    filter: brightness(1.2) saturate(1.3);
  }

  /* Efecto de "salir" de la terminal cuando hay hover */
  .terminal-slime:hover .slime-peeking {
    border-radius: 0;
    overflow: visible;
  }

  .slime-visible {
    opacity: 1 !important;
    transform: translateY(0) !important;
  }

  .slime-peeking {
    /* Efecto de asomarse desde el borde */
    overflow: hidden;
    border-radius: 50%;
  }

  .slime-image {
    width: 40px;
    height: auto;
    filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
    animation: slimePeek 4s ease-in-out infinite;
    transition: all 0.3s ease;
  }

  /* Animación más sutil cuando está detrás */
  .terminal-slime:not(:hover) .slime-image {
    filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.15));
    animation: slimePeekSubtle 8s ease-in-out infinite;
    opacity: 0.7;
  }

  /* Animación más expresiva cuando está enfrente (hover) */
  .terminal-slime:hover .slime-image {
    filter: drop-shadow(0 8px 16px rgba(0, 0, 0, 0.5));
    animation: slimePeekExcited 1.2s ease-in-out infinite;
    transform: scale(1.1);
  }

  @keyframes slimePeekSubtle {
    0%, 85%, 100% {
      transform: translateY(0) scale(1);
    }
    20%, 70% {
      transform: translateY(-2px) scale(1.005);
    }
    45% {
      transform: translateY(-1px) scale(1.002);
    }
  }

  @keyframes slimePeekExcited {
    0%, 100% {
      transform: scale(1.1) translateY(0);
    }
    25%, 75% {
      transform: scale(1.15) translateY(-8px);
    }
    50% {
      transform: scale(1.12) translateY(-4px);
    }
  }

  @keyframes slimePeek {
    0%, 70%, 100% {
      transform: translateY(0) scale(1);
    }
    10%, 60% {
      transform: translateY(-8px) scale(1.1);
    }
    35% {
      transform: translateY(-3px) scale(1.05);
    }
  }

  /* Animación de entrada más suave */
  .terminal-slime {
    transition: opacity 0.4s ease, transform 0.4s ease;
  }

  /* Responsive */
  @media (max-width: 768px) {
    .slime-image {
      width: 35px;
    }
    
    /* Ajustar peek amount para tablets */
    .slime-peeking {
      border-radius: 50%;
    }
  }

  @media (max-width: 480px) {
    .slime-image {
      width: 30px;
    }
    
    /* Ajustar peek amount para móviles */
    .slime-peeking {
      border-radius: 50%;
    }
  }

  /* Efecto de profundidad para simular que está detrás del borde */
  .slime-peeking::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.1);
    border-radius: 50%;
    z-index: -1;
  }

  /* Diálogo del slime */
  .slime-dialog {
    position: fixed;
    background: #ffffff;
    color: #000000;
    padding: 12px 16px;
    border-radius: 8px;
    font-size: 14px;
    font-family: 'Courier New', monospace;
    text-align: center;
    line-height: 1.4;
    border: 3px solid #000000;
    box-shadow: 2px 2px 0px #000000;
    z-index: 99999;
    pointer-events: none;
    max-width: 200px;
    display: none;
    opacity: 0;
    visibility: hidden;
  }

  .dialog-content {
    display: block;
  }

  .slime-dialog::after {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 8px solid transparent;
    border-top-color: #ffffff;
  }

  .slime-dialog::before {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 11px solid transparent;
    border-top-color: #000000;
    margin-top: 3px;
  }
</style>
